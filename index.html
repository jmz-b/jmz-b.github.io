<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>o_0</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
      }

      #c {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>
  <script type="module">
    import * as THREE from './node_modules/three/build/three.module.js';

    const cameraConfig = {
      fov: 40,
      aspect: 2,
      near: 0.1,
      far: 1000,
      position: [0, 0, 30],
    };

    const lightConfig = {
      color: 0xFFFFFF,
      intensity: 1,
      position: [-1, 2, 4],
    };

    const textConfig = {
      size: 3.0,
      height: 1.0,
      curveSegments: 12,
      bevelEnabled: true,
      bevelThickness: 0.15,
      bevelSize: .3,
      bevelSegments: 5,
      color: 0xff0000,
      position: [0, 0, 0],
    };

    class Camera extends THREE.PerspectiveCamera {
      constructor(config) {
        super(config.fov, config.aspect, config.near, config.far);
        this.position.set(...config.position);
      }
    }

    class Light extends THREE.DirectionalLight {
      constructor(config) {
        super(config.color, config.intensity);
        this.position.set(...config.position);
      }
    }

    class TextObject extends THREE.Object3D {
      constructor(text, font, config) {
        const material = new THREE.MeshPhongMaterial({color: config.color});
        const geometry = new THREE.TextBufferGeometry(text, {font, ...config});
        const mesh = new THREE.Mesh(geometry, material);

        geometry.computeBoundingBox();
        geometry.boundingBox.getCenter(mesh.position).multiplyScalar(-1);    

        super();
        this.add(mesh);
        this.position.set(...config.position);
      }
    }

    function resize(renderer, camera) {
      const canvas = renderer.domElement;
      const pixelRatio = window.devicePixelRatio;
      const width  = canvas.clientWidth  * pixelRatio | 0;
      const height = canvas.clientHeight * pixelRatio | 0;
      const needResize = canvas.width !== width || canvas.height !== height;

      if (needResize) {
        renderer.setSize(width, height, false);
        camera.aspect = canvas.clientWidth / canvas.clientHeight;
        camera.updateProjectionMatrix();
      }

      return needResize;
    }

    const renderer = new THREE.WebGLRenderer({canvas: document.querySelector('#c')});
    const scene = new THREE.Scene();
    const camera = new Camera(cameraConfig);
    const fontLoader = new THREE.FontLoader();

    const objects = [];
    const lights = [];

    fontLoader.load('font.json', (font) => {
      const text = new TextObject('JMZ', font, textConfig);
      scene.add(text);
      objects.push(text);
    });

    lights.push(new Light(lightConfig));
    lights.forEach(light => scene.add(light));

    requestAnimationFrame(function render(time) {
      const canvas = renderer.domElement;
      time *= 0.001;

      resize(renderer, camera);
      objects.forEach((obj) => obj.rotation.y = time);

      renderer.render(scene, camera);
      requestAnimationFrame(render);
    });
  </script>
</html>
